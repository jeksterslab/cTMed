---
title: "The Ornstein–Uhlenbeck Model"
author: "Ivan Jacob Agaloos Pesigan"
date: "`r Sys.Date()`"
bibliography: "vignettes.bib"
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
nocite: |
  @RCoreTeam-2023
  @Ou-Hunter-Chow-2019
  @Chow-Losardo-Park-etal-2023
  @Uhlenbeck-Ornstein-1930
  @Chow-Ho-Hamaker-etal-2010
  @Deboeck-Preacher-2015
  @Oravecz-Tuerlinckx-Vandekerckhove-2011
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{The Ornstein–Uhlenbeck Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include = FALSE
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "fig-vignettes-ou-",
  fig.cap = "",
  fig.width = 11,
  fig.height = 8,
  fig.retina = 2,
  dpi = 300,
  comment = "#>"
)
```

```{r}
#| include = FALSE
root <- rprojroot::is_rstudio_project
```

```{r}
#| include = FALSE
file <- root$find_file(
  "data",
  "deboeck2015.rda"
)
load(file = file)
```

```{r}
library(cTMed)
```

## Model

The measurement model is given by
\begin{equation}
  \mathbf{y}_{i, t}
  =
  \boldsymbol{\nu}
  +
  \boldsymbol{\Lambda}
  \boldsymbol{\eta}_{i, t}
  +
  \boldsymbol{\varepsilon}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\varepsilon}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Theta}
  \right)
\end{equation}
where
$\mathbf{y}_{i, t}$,
$\boldsymbol{\eta}_{i, t}$,
and
$\boldsymbol{\varepsilon}_{i, t}$
are random variables
and
$\boldsymbol{\nu}$,
$\boldsymbol{\Lambda}$,
and
$\boldsymbol{\Theta}$
are model parameters.
$\mathbf{y}_{i, t}$
represents a vector of observed random variables,
$\boldsymbol{\eta}_{i, t}$
a vector of latent random variables,
and
$\boldsymbol{\varepsilon}_{i, t}$
a vector of random measurement errors,
at time $t$ and individual $i$.
$\boldsymbol{\nu}$
denotes a vector of intercepts,
$\boldsymbol{\Lambda}$
a matrix of factor loadings,
and
$\boldsymbol{\Theta}$
the covariance matrix of
$\boldsymbol{\varepsilon}$.

An alternative representation of the measurement error
is given by
\begin{equation}
  \boldsymbol{\varepsilon}_{i, t}
  =
  \boldsymbol{\Theta}^{\frac{1}{2}}
  \mathbf{z}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \mathbf{z}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \mathbf{I}
  \right)
\end{equation}
where
$\mathbf{z}_{i, t}$ is a vector of
independent standard normal random variables and
$\left( \boldsymbol{\Theta}^{\frac{1}{2}} \right) \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)^{\prime} = \boldsymbol{\Theta}$ .

The dynamic structure is given by
\begin{equation}
  \mathrm{d} \boldsymbol{\eta}_{i, t}
  =
  - \boldsymbol{\Phi}
  \left(
  \boldsymbol{\mu}
  -
  \boldsymbol{\eta}_{i, t}
  \right)
  \mathrm{d}t
  +
  \boldsymbol{\Sigma}^{\frac{1}{2}}
  \mathrm{d}
  \mathbf{W}_{i, t}
\end{equation}
where
$\boldsymbol{\mu}$
is the long-term mean or equilibrium level,
$- \boldsymbol{\Phi}$
is the rate of mean reversion,
determining how quickly the variable returns to its mean,
$\boldsymbol{\Sigma}$
is the matrix of volatility
or randomness in the process, and
$\mathrm{d}\boldsymbol{W}$
is a Wiener process or Brownian motion,
which represents random fluctuations.

```{r}
#| eval = FALSE
data("deboeck2015phi", package = "cTMed")
```

```{r}
#| echo = FALSE
if (!exists("deboeck2015phi")) {
  try(
    data(
      "deboeck2015",
      package = "cTMed"
    ),
    silent = TRUE
  )
}
```

## Model Fitting using the `dynr` Package

### Prepare Data

Before fitting the model, we set a small $\Delta t$ and insert NAs on rows with missing observations.

```{r}
data <- dynUtils::InsertNA(
  data = deboeck2015,
  id = "id",
  time = "time",
  observed = c("x", "m", "y"),
  delta_t = 0.10,
  ncores = parallel::detectCores()
)
head(data)
```

```{r}
#| warning = FALSE,
#| message = FALSE
library(dynr)
```

```{r}
dynr_data <- dynr.data(
  dataframe = data,
  id = "id",
  time = "time",
  observed = c("x", "m", "y")
)
```

### Prepare Initial Condition

```{r}
dynr_initial <- prep.initial(
  values.inistate = rep(x = 0, times = 3),
  params.inistate = c("mu0_1", "mu0_2", "mu0_3"),
  values.inicov = diag(3),
  params.inicov = matrix(
    data = c(
      "sigma0_11", "sigma0_12", "sigma0_13",
      "sigma0_12", "sigma0_22", "sigma0_23",
      "sigma0_13", "sigma0_23", "sigma0_33"
    ),
    nrow = 3
  )
)
```

### Prepare Measurement Model

```{r}
dynr_measurement <- prep.measurement(
  values.load = diag(3),
  params.load = matrix(data = "fixed", nrow = 3, ncol = 3),
  state.names = c("eta_x", "eta_m", "eta_y"),
  obs.names = c("x", "m", "y")
)
```

### Prepare Dynamic Process

```{r}
dynr_dynamics <- prep.formulaDynamics(
  formula = list(  
    eta_x ~ phi_11 * eta_x + phi_12 * eta_m + phi_13 * eta_y,
    eta_m ~ phi_21 * eta_x + phi_22 * eta_m + phi_23 * eta_y,
    eta_y ~ phi_31 * eta_x + phi_32 * eta_m + phi_33 * eta_y
  ),
  startval = c(
    phi_11 = -0.357, phi_12 = 0, phi_13 = 0,
    phi_21 = 0.771, phi_22 = -0.511, phi_23 = 0,
    phi_31 = -0.450, phi_32 = 0.729, phi_33 = -0.693
  ),
  isContinuousTime = TRUE
)
```

### Prepare Process Noise

```{r}
dynr_noise <- prep.noise(
  values.latent = 0.01 * diag(3),
  params.latent = matrix(
    data = c(
      "sigma_11", "sigma_12", "sigma_13",
      "sigma_12", "sigma_22", "sigma_23",
      "sigma_13", "sigma_23", "sigma_33"
    ),
    nrow = 3
  ),
  values.observed = matrix(data = 0, nrow = 3, ncol = 3),
  params.observed = matrix(data = "fixed", nrow = 3, ncol = 3)
)
```

### Prepare the Model

```{r}
model <- dynr.model(
  data = dynr_data,
  initial = dynr_initial,
  measurement = dynr_measurement,
  dynamics = dynr_dynamics,
  noise = dynr_noise,
  outfile = "ou.c"
)
```

Set lower and upper bounds to aid in optimization.

```{r}
lb <- ub <- rep(NA, times = length(model$xstart))
names(ub) <- names(lb) <- names(model$xstart)
lb[
  c(
    "phi_11",
    "phi_21",
    "phi_31",
    "phi_12",
    "phi_22",
    "phi_32",
    "phi_13",
    "phi_23",
    "phi_33"
  )
] <- -1.5
ub[
  c(
    "phi_11",
    "phi_21",
    "phi_31",
    "phi_12",
    "phi_22",
    "phi_32",
    "phi_13",
    "phi_23",
    "phi_33"
  )
] <- 1.5
model$lb <- lb
model$ub <- ub
```

```{r model}
#| echo = FALSE
plotFormula(
  dynrModel = model,
  ParameterAs = model$"param.names",
  printDyn = TRUE,
  printMeas = TRUE
)
```

### Fit the Model

```{r}
dynr_fit <- dynr.cook(
  model,
  debug_flag = TRUE,
  verbose = FALSE
)
```

## Summary

```{r}
summary(dynr_fit)
```

```{r}
parnames <- c(
  "phi_11",
  "phi_21",
  "phi_31",
  "phi_12",
  "phi_22",
  "phi_32",
  "phi_13",
  "phi_23",
  "phi_33"
)
phi_vec <- coef(dynr_fit)[parnames]
phi <- matrix(
  data = phi_vec,
  nrow = 3
)
colnames(phi) <- rownames(phi) <- c("x", "m", "y")
vcov_phi_vec <- vcov(dynr_fit)[parnames, parnames]
dynr <- list(
  phi = phi,
  vcov = vcov_phi_vec
)
```

```{r}
#| echo = FALSE
unlink(
  c(
    "ou.c",
    "ou.o",
    "ou.so"
  )
)
```

## Model Fitting using the `ctsem` Package

### Define the Model

```{r}
#| warning = FALSE,
#| message = FALSE
library(ctsem)
```

```{r}
#| warning = FALSE,
#| message = FALSE
model <- ctModel(
  type = "stanct",
  manifestNames = c("x", "m", "y"),
  latentNames = c("eta_x", "eta_m", "eta_y"),
  id = "id",
  time = "time",
  silent = TRUE,
  LAMBDA = diag(3),
  DRIFT = "auto",
  MANIFESTMEANS = matrix(data = 0, nrow = 3, ncol = 1),
  MANIFESTVAR = diag(0, 3),
  CINT = "auto",
  DIFFUSION = "auto"
)
```

### Fit the Model

```{r}
#| warning = FALSE,
#| message = FALSE
set.seed(42)
ctsem_fit <- ctStanFit(
  datalong = data,
  ctstanmodel = model,
  optimize = TRUE,
  cores = parallel::detectCores()
)
```

### Summary

```{r}
summary(ctsem_fit)
```

### Extract the Posterior Distribution of the Drift Matrix

```{r}
posterior <- ctExtract(ctsem_fit)$pop_DRIFT
posterior_phi <- lapply(
  X = seq_len(dim(posterior)[1]),
  FUN = function(i) {
    phi <- posterior[i, , ]
    colnames(phi) <- rownames(phi) <- c("x", "m", "y")
    return(phi)
  }
)
posterior_phi_vec <- lapply(
  X = posterior_phi,
  FUN = function(i) {
    dim(i) <- NULL
    return(i)
  }
)
phi_vec <- colMeans(do.call(what = "rbind", args = posterior_phi_vec))
phi <- matrix(
  data = phi_vec,
  nrow = 3
)
colnames(phi) <- rownames(phi) <- c("x", "m", "y")
vcov_phi_vec <- var(do.call(what = "rbind", args = posterior_phi_vec))
ctsem <- list(
  posterior = posterior,
  posterior_phi = posterior_phi,
  phi = phi,
  vcov = vcov_phi_vec
)
```

```{r}
deboeck2015phi <- list(
  dynr = dynr,
  ctsem = ctsem
)
```

```{r}
#| include = FALSE
deboeck2015phi_rda <- root$find_file(
  "data",
  "deboeck2015phi.rda"
)
if (!file.exists(deboeck2015phi_rda)) {
  save(
    deboeck2015phi,
    file = deboeck2015phi_rda,
    compress = "xz"
  )
}
```

## References

```{r}
#| include = FALSE
rm(list = ls())
```
